{"ast":null,"code":"/*! Selectionjs 1.7.0 MIT | https://github.com/Simonwep/selection */\n!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == typeof exports ? exports.Selection = t() : e.Selection = t();\n}(window, function () {\n  return function (e) {\n    var t = {};\n\n    function n(o) {\n      if (t[o]) return t[o].exports;\n      var r = t[o] = {\n        i: o,\n        l: !1,\n        exports: {}\n      };\n      return e[o].call(r.exports, r, r.exports, n), r.l = !0, r.exports;\n    }\n\n    return n.m = e, n.c = t, n.d = function (e, t, o) {\n      n.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: o\n      });\n    }, n.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"u\", {\n        value: !0\n      });\n    }, n.t = function (e, t) {\n      if (1 & t && (e = n(e)), 8 & t) return e;\n      if (4 & t && \"object\" == typeof e && e && e.u) return e;\n      var o = Object.create(null);\n      if (n.r(o), Object.defineProperty(o, \"default\", {\n        enumerable: !0,\n        value: e\n      }), 2 & t && \"string\" != typeof e) for (var r in e) n.d(o, r, function (t) {\n        return e[t];\n      }.bind(null, r));\n      return o;\n    }, n.n = function (e) {\n      var t = e && e.u ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return n.d(t, \"a\", t), t;\n    }, n.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.p = \"dist/\", n(n.s = 1);\n  }([function (e) {\n    e.exports = JSON.parse('{\"a\":\"1.7.0\"}');\n  }, function (e, t, n) {\n    \"use strict\";\n\n    function o(e, t) {\n      var n = Object.keys(e);\n\n      if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        t && (o = o.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), n.push.apply(n, o);\n      }\n\n      return n;\n    }\n\n    function r(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var n = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? o(Object(n), !0).forEach(function (t) {\n          c(e, t, n[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : o(Object(n)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));\n        });\n      }\n\n      return e;\n    }\n\n    function c(e, t, n) {\n      return t in e ? Object.defineProperty(e, t, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : e[t] = n, e;\n    }\n\n    function l(e, t, n, o, c = {}) {\n      t instanceof HTMLCollection || t instanceof NodeList ? t = Array.from(t) : Array.isArray(t) || (t = [t]), Array.isArray(n) || (n = [n]);\n\n      for (const l of t) for (const t of n) l[e](t, o, r({\n        capture: !1\n      }, c));\n\n      return Array.prototype.slice.call(arguments, 1);\n    }\n\n    n.r(t);\n\n    const s = l.bind(null, \"addEventListener\"),\n          i = l.bind(null, \"removeEventListener\"),\n          a = (e, t = \"px\") => \"number\" == typeof e ? e + t : e;\n\n    function u(e, t, n) {\n      const o = e && e.style;\n      if (o) if (\"object\" == typeof t) for (const [e, n] of Object.entries(t)) o[e] = a(n);else n && \"string\" == typeof t && (o[t] = a(n));\n    }\n\n    function f(e, t, n) {\n      switch (n || \"touch\") {\n        case \"center\":\n          {\n            const n = t.left + t.width / 2,\n                  o = t.top + t.height / 2;\n            return n >= e.left && n <= e.right && o >= e.top && o <= e.bottom;\n          }\n\n        case \"cover\":\n          return t.left >= e.left && t.top >= e.top && t.right <= e.right && t.bottom <= e.bottom;\n\n        case \"touch\":\n          return e.right >= t.left && e.left <= t.right && e.bottom >= t.top && e.top <= t.bottom;\n\n        default:\n          throw new Error(\"Unkown intersection mode: \".concat(n));\n      }\n    }\n\n    function d(e, t = document) {\n      Array.isArray(e) || (e = [e]);\n      const n = [];\n\n      for (let o = 0, r = e.length; o < r; o++) {\n        const r = e[o];\n        \"string\" == typeof r ? n.push(...t.querySelectorAll(r)) : r instanceof t.defaultView.HTMLElement && n.push(r);\n      }\n\n      return n;\n    }\n\n    function m(e) {\n      let t = e.path || e.composedPath && e.composedPath();\n      if (t && t.length > 0) return t;\n      let n = e.target;\n\n      for (t = [n]; n = n.parentElement;) t.push(n);\n\n      return t.push(document, window), t;\n    }\n\n    function p(e, t) {\n      const n = e.indexOf(t);\n      ~n && e.splice(n, 1);\n    }\n\n    function v(e) {\n      const t = e.touches && e.touches[0] || e;\n      return {\n        tap: t,\n        x: t.clientX,\n        y: t.clientY,\n        target: t.target\n      };\n    }\n\n    var b = n(0);\n\n    const {\n      abs: h,\n      max: y,\n      min: _,\n      round: g,\n      ceil: w\n    } = Math,\n          j = e => e.preventDefault();\n\n    function x(e = {}) {\n      const t = {\n        options: Object.assign({\n          class: \"selection-area\",\n          frame: document,\n          mode: \"touch\",\n          tapMode: \"native\",\n          startThreshold: 10,\n          singleClick: !0,\n          disableTouch: !1,\n          selectables: [],\n          scrollSpeedDivider: 10,\n          manualScrollSpeed: 750,\n          startareas: [\"html\"],\n          boundaries: [\"html\"],\n          selectionAreaContainer: \"body\"\n        }, e),\n        v: [],\n        h: [],\n        _: [],\n        g: {\n          added: [],\n          removed: []\n        },\n        j: {\n          beforestart: [],\n          start: [],\n          move: [],\n          stop: []\n        },\n        O: null,\n        S: null,\n        T: null,\n        A: !0,\n        M: {\n          x: null,\n          y: null\n        },\n\n        L() {\n          const {\n            frame: e\n          } = t.options;\n          t.O = e.createElement(\"div\"), t.T = e.createElement(\"div\"), t.T.appendChild(t.O), t.O.classList.add(t.options.class), u(t.O, {\n            willChange: \"top, left, bottom, right, width, height\",\n            top: 0,\n            left: 0,\n            position: \"fixed\"\n          }), u(t.T, {\n            overflow: \"hidden\",\n            position: \"fixed\",\n            transform: \"translate3d(0, 0, 0)\",\n            pointerEvents: \"none\",\n            zIndex: \"1\"\n          }), t.enable();\n        },\n\n        k(e) {\n          const {\n            frame: n\n          } = t.options,\n                o = \"on\" === e ? s : i;\n          o(n, \"mousedown\", t.C), t.options.disableTouch || o(n, \"touchstart\", t.C, {\n            passive: !1\n          });\n        },\n\n        C(e, n = !1) {\n          const {\n            x: o,\n            y: r,\n            target: c\n          } = v(e),\n                {\n            startareas: l,\n            boundaries: i,\n            frame: a\n          } = t.options,\n                u = c.getBoundingClientRect(),\n                p = d(l, a);\n          t.D = d(i, a), t.R = t.D.find(e => f(e.getBoundingClientRect(), u));\n          const b = m(e);\n          t.R && p.find(e => b.includes(e)) && t.D.find(e => b.includes(e)) && (n || !1 !== t.F(\"beforestart\", e)) && (t.H = o, t.q = r, t.N = 0, t.U = 0, t.W = !0, t.clearSelection(!1), s(a, \"selectstart\", j), s(a, [\"touchmove\", \"mousemove\"], t.I, {\n            passive: !1\n          }), s(a, [\"mouseup\", \"touchcancel\", \"touchend\"], t.J), e.preventDefault());\n        },\n\n        P(e) {\n          const {\n            tapMode: n\n          } = t.options,\n                o = v(e);\n          let r = null;\n          if (\"native\" === n) r = o.target;else {\n            if (\"touch\" !== n) throw new Error(\"Unknown tapMode option: \".concat(n));\n            {\n              t.resolveSelectables();\n              const {\n                x: e,\n                y: n\n              } = o;\n              r = t.h.find(t => {\n                const {\n                  right: o,\n                  left: r,\n                  top: c,\n                  bottom: l\n                } = t.getBoundingClientRect();\n                return e < o && e > r && n < l && n > c;\n              });\n            }\n          }\n          if (!r) return !1;\n\n          for (t.resolveSelectables(); !t.h.includes(r);) {\n            if (!r.parentElement) return;\n            r = r.parentElement;\n          }\n\n          t.F(\"start\", e);\n          const c = t.v;\n\n          if (e.shiftKey && c.length) {\n            const n = c[c.length - 1],\n                  [o, l] = 4 & n.compareDocumentPosition(r) ? [r, n] : [n, r],\n                  s = [...t.h.filter(e => 4 & e.compareDocumentPosition(o) && 2 & e.compareDocumentPosition(l)), r];\n            t.select(s), t.F(\"move\", e), t.F(\"stop\", e);\n          } else t.v.includes(r) ? t.removeFromSelection(r) : t.select(r), t.F(\"move\", e), t.F(\"stop\", e);\n        },\n\n        I(e) {\n          const {\n            x: n,\n            y: o\n          } = v(e),\n                {\n            startThreshold: r,\n            frame: c\n          } = t.options,\n                {\n            H: l,\n            q: a\n          } = t,\n                f = typeof r;\n\n          if (\"number\" === f && h(n + o - (l + a)) >= r || \"object\" === f && h(n - l) >= r.x || h(o - a) >= r.y) {\n            i(c, [\"mousemove\", \"touchmove\"], t.I, {\n              passive: !1\n            }), s(c, [\"mousemove\", \"touchmove\"], t.B, {\n              passive: !1\n            }), u(t.O, \"display\", \"block\"), d(t.options.selectionAreaContainer, c)[0].appendChild(t.T), t.resolveSelectables(), t.W = !1;\n            const n = t.G = t.R.getBoundingClientRect();\n            g(t.R.scrollHeight) !== g(n.height) || g(t.R.scrollWidth) !== g(n.width) ? (t.A = !0, s(window, \"wheel\", t.K, {\n              passive: !1\n            }), t.h = t.h.filter(e => t.R.contains(e)), u(t.T, {\n              top: n.top,\n              left: n.left,\n              width: n.width,\n              height: n.height\n            }), u(t.O, {\n              marginTop: -n.top,\n              marginLeft: -n.left\n            })) : (t.A = !1, u(t.T, {\n              top: 0,\n              left: 0,\n              width: \"100%\",\n              height: \"100%\"\n            }), u(t.O, {\n              marginTop: 0,\n              marginLeft: 0\n            })), t.B(e), t.F(\"start\", e);\n          }\n\n          e.preventDefault();\n        },\n\n        B(e) {\n          const {\n            x: n,\n            y: o\n          } = v(e),\n                {\n            scrollSpeedDivider: r\n          } = t.options,\n                c = t.R;\n          let l = t.M;\n          t.N = n, t.U = o, !t.A || null === l.y && null === l.x ? (t.V(), t.X(), t.F(\"move\", e), t.Y()) : requestAnimationFrame(function n() {\n            l = t.M;\n            const o = null !== l.y,\n                  s = null !== l.x;\n            if (!o && !s) return;\n            const {\n              scrollTop: i,\n              scrollLeft: a\n            } = c;\n            o && (c.scrollTop += w(l.y / r), t.q -= c.scrollTop - i), s && (c.scrollLeft += w(l.x / r), t.H -= c.scrollLeft - a), t.V(), t.X(), t.F(\"move\", e), t.Y(), requestAnimationFrame(n);\n          }), e.preventDefault();\n        },\n\n        K(e) {\n          const {\n            manualScrollSpeed: n\n          } = t.options,\n                o = e.deltaY ? e.deltaY > 0 ? 1 : -1 : 0,\n                r = e.deltaX ? e.deltaX > 0 ? 1 : -1 : 0;\n          t.M.y += o * n, t.M.x += r * n, t.B(e), e.preventDefault();\n        },\n\n        V() {\n          const {\n            scrollTop: e,\n            scrollHeight: n,\n            clientHeight: o,\n            scrollLeft: r,\n            scrollWidth: c,\n            clientWidth: l\n          } = t.R,\n                s = t.G,\n                i = t.M;\n          let a = t.N,\n              u = t.U;\n          a < s.left ? (i.x = r ? -h(s.left - a) : null, a = s.left) : a > s.left + s.width ? (i.x = c - r - l ? h(s.left + s.width - a) : null, a = s.left + s.width) : i.x = null, u < s.top ? (i.y = e ? -h(s.top - u) : null, u = s.top) : u > s.top + s.height ? (i.y = n - e - o ? h(s.top + s.height - u) : null, u = s.top + s.height) : i.y = null;\n\n          const f = _(t.H, a),\n                d = _(t.q, u),\n                m = y(t.H, a),\n                p = y(t.q, u);\n\n          t.S = new DOMRect(f, d, m - f, p - d);\n        },\n\n        Y() {\n          const {\n            x: e,\n            y: n,\n            width: o,\n            height: r\n          } = t.S,\n                c = t.O.style;\n          c.transform = \"translate3d(\" + e + \"px,\" + n + \"px, 0)\", c.width = o + \"px\", c.height = r + \"px\";\n        },\n\n        J(e, n) {\n          const {\n            frame: o,\n            singleClick: r\n          } = t.options;\n          i(o, [\"mousemove\", \"touchmove\"], t.I), i(o, [\"touchmove\", \"mousemove\"], t.B), i(o, [\"mouseup\", \"touchcancel\", \"touchend\"], t.J), e && t.W && r ? t.P(e) : t.W || n || (t.X(), t.F(\"stop\", e)), t.M = {\n            x: null,\n            y: null\n          }, i(window, \"wheel\", t.K), t.T.remove(), i(o, \"selectstart\", j), u(t.O, \"display\", \"none\");\n        },\n\n        X() {\n          const {\n            _: e,\n            h: n,\n            options: o,\n            S: r\n          } = t,\n                {\n            mode: c\n          } = o,\n                l = [],\n                s = [],\n                i = [];\n\n          for (let t = 0; t < n.length; t++) {\n            const o = n[t];\n            f(r, o.getBoundingClientRect(), c) && (e.includes(o) || s.push(o), l.push(o));\n          }\n\n          for (let t = 0; t < e.length; t++) {\n            const n = e[t];\n            l.includes(n) || i.push(n);\n          }\n\n          t._ = l, t.g = {\n            added: s,\n            removed: i\n          };\n        },\n\n        F(e, n) {\n          let o = !0;\n\n          for (const r of t.j[e]) o = r.call(t, {\n            inst: t,\n            area: t.O,\n            selected: t._.concat(t.v),\n            changed: t.g,\n            oe: n\n          }) && o;\n\n          return o;\n        },\n\n        trigger(e, n = !0) {\n          t.C(e, n);\n        },\n\n        on: (e, n) => (t.j[e].push(n), t),\n\n        off(e, n) {\n          const o = t.j[e];\n\n          if (o) {\n            const e = o.indexOf(n);\n            ~e && o.splice(e, 1);\n          }\n\n          return t;\n        },\n\n        resolveSelectables() {\n          t.h = d(t.options.selectables, t.options.frame);\n        },\n\n        keepSelection() {\n          const {\n            _: e,\n            v: n\n          } = t;\n\n          for (let t = 0; t < e.length; t++) {\n            const o = e[t];\n            n.includes(o) || n.push(o);\n          }\n        },\n\n        clearSelection(e = !0) {\n          e && (t.v = []), t._ = [], t.g.added = [], t.g.removed = [];\n        },\n\n        removeFromSelection(e) {\n          t.g.removed.push(e), p(t.v, e), p(t._, e);\n        },\n\n        getSelection: () => t.v,\n\n        cancel(e = !1) {\n          t.J(null, !e);\n        },\n\n        option(e, n) {\n          const {\n            options: o\n          } = t;\n          return void 0 === n ? o[e] : o[e] = n;\n        },\n\n        disable() {\n          t.k(\"off\");\n        },\n\n        destroy() {\n          t.disable(), t.T.remove();\n        },\n\n        enable() {\n          t.k(\"on\");\n        },\n\n        select(e) {\n          const {\n            _: n,\n            v: o,\n            options: r\n          } = t,\n                c = d(e, r.frame).filter(e => !n.includes(e) && !o.includes(e));\n          return t._.push(...c), t.g.added.push(...c), c;\n        }\n\n      };\n      return t.L(), t;\n    }\n\n    x.utils = {\n      on: s,\n      off: i,\n      css: u,\n      intersects: f,\n      selectAll: d,\n      eventPath: m,\n      removeElement: p\n    }, x.create = e => x(e), x.version = b.a;\n    t.default = x;\n  }]).default;\n});","map":null,"metadata":{},"sourceType":"script"}